###### 题目从易到难



### 1.汉明距离

两个整数之间的[汉明距离](https://baike.baidu.com/item/汉明距离)指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和 y，计算它们之间的汉明距离。

0 <= x，y <= 2 ^32^。

示例：

```
输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
```

------

首先对两个数求异或，结果中1的个数就是两个数的汉明距离。

求二进制中1个数的方法：

- 移位，计数

  循环如下： count += n & 1;	n >>= 1

- 通过 n & (n - 1) 清右侧1

  示例： 8(1000) & 7(0111) = (0000)

- 动态初始化表

  将数等分为几个部分，如4部分，每部分有8位，构造一个256(2^8^)元素的列表。构造表时的原理：n为偶数时，n的二进制中1的个数与n/2中的个数相同。n为奇数时，n中1的个数为n/2中1的个数+1。构造表时循环结果：c[i] = i&1(判断奇偶 ) + c[i/2]。

eg：还有平行算法，和以4a+2b+c - (2a+b) - a = a + b + c为思想的方法。

### 2.合并二叉树

给定两个二叉树，想象将他们重的一个覆盖到另一个上，两个二叉树的一些节点就会重叠。

示例：

```
输入: 
	      Tree 1                    Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```

二叉树的遍历方式

- 前序遍历
- 中序遍历
- 后续遍历
- 深度优先（顺序与前序相同）
- 广度优先

代码：

```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if (root1 == nullptr)
            return root2;
        if (root2 == nullptr)
            return root1;
        
        auto merge = new TreeNode(root1->val + root2->val);
        merge->left = mergeTrees(root1->left, root2->left);
        merge->right = mergeTrees(root1->right, root2->right);
        return merge;
    }
};
```

->：通过指针访问结构体成员，不能使用. 使用->。

节点为空时直接返回。不改变原来的二叉树不代表每个节点都要new。多个二叉树可以共用节点指针。一个节点为null时直接将另外的二叉树对应节点返回比较巧妙。

### 3.二叉树的最大深度

给定一个二叉树，找出其最大深度

示例：

```
    3
   / \
  9  20
    /  \
   15   7
```

返回他的最大深度3。

- 方法1:

DFS深度优先搜索，通过递归，函数名为maxDepth，跟节点root不为空时，返回max(maxDepth(root->left), maxDepth(root->right)) + 1;

- 方法2:

BFS广度优先搜索，引入队列，将树的一层节点先放入队列中并计数，根据个数出队，并入队该出队节点的左右孩子节点（如果存在的话），定义另外的变量记录层数最后返回，该方法不用递归。

### 4.只出现一次的数字

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

示例：

~~~
输入: [2,2,1]
输出: 1
~~~

- 方法：

使用异或运算。异或运算有以下三个性质

1. 任何数与0做异或运算，结果仍为原来的数。
2. 任何数与自身做异或运算，结果都为0。
3. 异或运算满足交换律和结合律。

则将数组中的数依次做异或，根据性质3，异或前后的顺序不影响结果，因此最后的运算结果即为数组中只出现一次的数字。

